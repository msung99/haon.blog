---
title: 자바의 레퍼 클래스 (Wrapper Class)
date: "2024-07-12"
tags:
  - JAVA
previewImage: java.png
series: JAVA, 객체지향, 디자인패턴 학습기록
---

## 학습동기

최근부터 시작해서 자바에 대해 학습을 이어오면서, 이전에 무심코 활용했던 레퍼 클래스에 대하여 다시 주의해여 사용해야할 키워드들을 많이 발견했습니다. 이에 대하여 제대로 정리를해보고자, 이번에는 레퍼 클래스와 기본 타입에 대한 올바른 사용방법에 대하여 다루어보고자 합니다.

---

## 박싱(Boxing) 과 데이터 타입

```java
Integer num1 = new Integer(3); // 레퍼 클래스
int num2 = 3; // 기본 타입
```

`박싱(Boxing)` 은 원시타입에 해당하는 레퍼 클래스의 객체로 변환하는 행위를 뜻합니다. 이 반대는 언박싱(UnBoxing) 이겠죠. 또 레퍼 클래스의 경우 `참조 데이터 타입(reference type)` 에 해닿하며, `기본 데이터 타입(primitive type)` 은 int, long 과 같은 것들이 해당됩니다.

---

## 레퍼 클래스보다는 기본 타입을 지향하자.

레퍼 클래스는 객체지향인 관점에서 다양한 기능을 제공해주기 때문에, 어디서든 적재적소로 활용하고 싶은 유횩에 빠져들 수 밖에 없습니다. 그러나, 이에대한 사용시 고려사항도 여럿 존재합니다.

### 연산 속도가 매우 느려질 수 있다.

```java
Long num = 100L;
for(long i=0; i <= 100; i++){
	num += i;
}
```

위 코드는 컴파일 오류도 발생하지 않고, 로직에 문제도 없어보입니다. 다만 매우 치명적인 단점이 있는데, 그건 바로 박싱(Boxing) 된 객체를 매번 언박싱 해야하는 비용이 계속해서 발생하기 때문에 성능이 매우 느립니다. **레퍼 클래스를 기본 타입과 함께 혼용한 연산에서는 박상된 기본 타입이 자동으로 풀리므로, 이로 인해 연산 성능이 저하되지 않는지를** 항상 고려하는 것이 좋습니다.

또한 기본 타입의 경우 모두 데이터 값을 직접 저장하므로 연산에 있어 좋은 성능을 보이지만, 참조 데이터 타입의 경우 메모리에 객체의 주소값을 저장합니다. 때문에 레퍼 클래스를 사용한다는 그 자체로 메모리 사용 측면 및 연산속도에서 비효율적일 수 있습니다.

### NullPointerException 가 발생할 수 있음에 대비하자.

```java
Integer i;

if(i == 100) {
  System.out.println("오류 없이 진입성공!");
}
```

기본 타입의 값은 언제나 유효하지만, 레퍼 클래스의 경우 유효하지 않은 값 `null` 을 가질 수 있음을 유념해야합니다. 위의 경우 int 가 아니라 Integer 로 아무값 지정없이 초기화했기 때문에 null 로 초기화 될 것입니다. 앞서 말했듯이 기본 타입과 레퍼 클래스 타입을 혼용한 연산에서는 박싱된 타입이 자동으로 언박싱 되므로 null 을 참조하는 값을 언박싱하면 `NullPointerException` 이 발생하게 됩니다.

### 박싱된 값은 식별성(identity) 속성을 갖는다.

```java
Integer a = 200;
Integer b = 200;
// a == b   => false
```

> equals() 에 대한 자세한 내용은 [[JAVA] Object.equals 의 일반 규약을 지켜서 재정의하라](https://velog.io/@msung99/JAVA-Object.equals-%EC%9D%98-%EC%9D%BC%EB%B0%98-%EA%B7%9C%EC%95%BD%EC%9D%84-%EC%A7%80%EC%BC%9C%EC%84%9C-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC) 을 참고하자.

기본 타입의 경우 값만 저장하게 되지만, 박싱된 기본 타입인 레퍼 클래스는 값 말고도 식별성(identity) 속성을 가집니다. 이전에 다루었듯이 "==" 연산은 참조를 비교하는 것이므로 같은 값을 보유했더라도 서로 다른 객체라면 동등성 비교 결과가 false 라고 했었습니다. 때문에 두 레퍼 객체의 값을 비교하고 싶다면, `equals()` 를 활용해야 함에 주의합시다.

---

## 언제 레퍼 클래스 타입을 사용해야할까?

그렇다면 레퍼 클래스보다 반드시 기본 타입의 사용을 지향해야하는가? 라는 생각이 들 수 있겠지만, 항상 그런것은 아닙니다. 박싱된 기본타입을 사용해야하는 경우를 나열해보면 다음과 같습니다.

- 컬렉션을 활용해서 값을 저장해야 하는경우
- 리플랙션을 통해 메소드를 호출해야 할때

컬렉션의 경우는 기본타입을 담을 수 없기 때문에, 박싱된 레퍼 타입을 사용해야합니다. 리플랙션은 아직 이해도가 부족하기 떄문에, 추후 학습후에 이에대한 내용을 자세히 다루어보고자 합니다.

---

## 참고

- https://okeybox.tistory.com/437
- https://dahye-jeong.gitbook.io/java/java/effective_java/2021-07-25-prefer-primitivie-types-to-boxed-primitives
